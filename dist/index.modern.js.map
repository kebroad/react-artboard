{"version":3,"file":"index.modern.js","sources":["../src/tools/brush/brushHelpers.ts","../src/utils/cursors.ts","../src/tools/brush/useBrush.ts","../src/tools/marker/useMarker.ts","../src/tools/airbrush/useAirbrush.ts","../src/tools/shading/useShadingBrush.ts","../src/tools/watercolor/watercolor.ts","../src/tools/watercolor/useWatercolor.ts","../src/tools/eraser/useEraser.ts","../src/tools/pencil/usePencil.ts","../src/tools/charcoal/useCharcoal.ts","../src/tools/calligraphy/useCalligraphy.ts","../src/tools/inkpen/useInkPen.ts","../src/tools/oilpaint/useOilPaint.ts","../src/tools/acrylic/useAcrylic.ts","../src/tools/crayon/useCrayon.ts","../src/tools/smudge/useSmudge.ts","../src/utils/pointUtils.ts","../src/components/Artboard.tsx","../src/history.ts"],"sourcesContent":["import tinycolor from \"tinycolor2\";\nimport { Point } from \"../../utils/pointUtils\";\n\nexport function varyColour(\n  sourceColour: string,\n  varyBrightness: number\n): string {\n  const amount = Math.round(Math.random() * varyBrightness);\n  const alpha = 1 - Math.random() / 4;\n  const colour = tinycolor(sourceColour);\n  const varied = colour.darken(amount - varyBrightness / 2).setAlpha(alpha);\n  return varied.toPercentageRgbString();\n}\n\nexport interface Bristle {\n  distance: number;\n  thickness: number;\n  colour: string;\n}\n\nexport const rotatePoint = (\n  distance: number,\n  angle: number,\n  origin: Point\n): Point => [\n  origin[0] + distance * Math.cos(angle),\n  origin[1] + distance * Math.sin(angle),\n];\n\nexport const getBearing = (origin: Point, destination: Point): number =>\n  (Math.atan2(destination[1] - origin[1], destination[0] - origin[0]) -\n    Math.PI / 2) %\n  (Math.PI * 2);\n\nexport const getNewAngle = (\n  origin: Point,\n  destination: Point,\n  oldAngle?: number\n): number => {\n  const bearing = getBearing(origin, destination);\n  if (typeof oldAngle === \"undefined\") {\n    return bearing;\n  }\n  return oldAngle - angleDiff(oldAngle, bearing);\n};\n\nexport const angleDiff = (angleA: number, angleB: number): number => {\n  const twoPi = Math.PI * 2;\n  const diff =\n    ((angleA - (angleB > 0 ? angleB : angleB + twoPi) + Math.PI) % twoPi) -\n    Math.PI;\n  return diff < -Math.PI ? diff + twoPi : diff;\n};\n","export function circleSVG(diameter: number) {\n  return `<svg xmlns='http://www.w3.org/2000/svg' width='${diameter}' height='${diameter}' viewBox='0 0 ${diameter} ${diameter}'><circle r='${\n    diameter / 2\n  }' cy='${diameter / 2}' cx='${\n    diameter / 2\n  }' stroke-width='1' stroke='rgba(0,0,0,0.5)' fill='none'/></svg>`;\n}\n\nexport function circleDataUri(diameter: number) {\n  return `data:image/svg+xml;base64,${btoa(circleSVG(diameter))}`;\n}\n\nexport function circleCursor(diameter: number) {\n  return `url(${circleDataUri(diameter)}) ${diameter / 2} ${\n    diameter / 2\n  }, crosshair`;\n}\n","import { useCallback, useRef, useState } from \"react\";\n\nimport { Bristle, getNewAngle, rotatePoint, varyColour } from \"./brushHelpers\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport type Brush = Array<Bristle>;\n\nfunction makeBrush(\n  strokeWidth: number,\n  colour: string,\n  varyBrightness: number\n): Brush {\n  const brush: Brush = [];\n  const bristleCount = Math.round(strokeWidth / 3);\n  const gap = strokeWidth / bristleCount;\n  for (let i = 0; i < bristleCount; i++) {\n    const distance =\n      i === 0 ? 0 : gap * i + (Math.random() * gap) / 2 - gap / 2;\n    brush.push({\n      distance,\n      thickness: Math.random() * 2 + 2,\n      colour: varyColour(colour, varyBrightness),\n    });\n  }\n  return brush;\n}\n\nconst strokeBristle = (\n  origin: Point,\n  destination: Point,\n  bristle: Bristle,\n  controlPoint: Point,\n  context: CanvasRenderingContext2D\n) => {\n  context.beginPath();\n  context.moveTo(origin[0], origin[1]);\n  context.strokeStyle = bristle.colour;\n  context.lineWidth = bristle.thickness;\n  context.lineCap = \"round\";\n  context.lineJoin = \"round\";\n  context.shadowColor = bristle.colour;\n  context.shadowBlur = bristle.thickness / 2;\n  context.quadraticCurveTo(\n    controlPoint[0],\n    controlPoint[1],\n    destination[0],\n    destination[1]\n  );\n  context.lineTo(destination[0], destination[1]);\n  context.stroke();\n};\n\nconst drawStroke = (\n  bristles: Brush,\n  origin: Point,\n  destination: Point,\n  oldAngle: number,\n  newAngle: number,\n  strokeWidth: number,\n  context: CanvasRenderingContext2D\n) => {\n  bristles.forEach((bristle) => {\n    context.beginPath();\n    const bristleOrigin = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      oldAngle,\n      origin\n    );\n\n    const bristleDestination = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      newAngle,\n      destination\n    );\n    const controlPoint = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      newAngle,\n      origin\n    );\n\n    strokeBristle(\n      bristleOrigin,\n      bristleDestination,\n      bristle,\n      controlPoint,\n      context\n    );\n  });\n};\n\nexport interface UseBrushProps {\n  color?: string;\n  strokeWidth?: number;\n  varyBrightness?: number;\n}\n\nexport function useBrush({\n  color = \"#000000\",\n  strokeWidth = 25,\n  varyBrightness = 5,\n}: UseBrushProps): ToolHandlers {\n  const [brush, setBrush] = useState<Brush>([]);\n  const currentAngle = useRef<number>();\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point) => {\n      currentAngle.current = undefined;\n      setBrush(makeBrush(strokeWidth, color, varyBrightness));\n      lastPoint.current = point;\n    },\n    [setBrush, strokeWidth, color, varyBrightness]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = newPoint;\n        return;\n      }\n      const newAngle = getNewAngle(\n        lastPoint.current,\n        newPoint,\n        currentAngle.current\n      );\n      if (typeof currentAngle.current === \"undefined\") {\n        currentAngle.current = newAngle % (Math.PI * 2);\n      }\n      drawStroke(\n        brush,\n        lastPoint.current,\n        newPoint,\n        currentAngle.current,\n        newAngle,\n        strokeWidth,\n        context\n      );\n      currentAngle.current = newAngle % (Math.PI * 2);\n      lastPoint.current = newPoint;\n    },\n    [brush, strokeWidth]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Paintbrush\", startStroke, continueStroke, cursor };\n}\n","import { useCallback, useRef } from \"react\";\n\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseMarkerProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useMarker({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseMarkerProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineWidth = 3;\n      context.lineJoin = context.lineCap = \"round\";\n      lastPoint.current = point;\n      context.strokeStyle = color;\n    },\n    [color]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = newPoint;\n        return;\n      }\n      if (\n        lastPoint.current[0] === newPoint[0] &&\n        lastPoint.current[1] === newPoint[1]\n      ) {\n        return;\n      }\n      context.beginPath();\n\n      for (let i = 0; i < strokeWidth; i += 2) {\n        const offset = Math.round(strokeWidth / 2 - i);\n        context.globalAlpha = (1 / strokeWidth) * (strokeWidth - i);\n        context.moveTo(\n          lastPoint.current[0] - offset,\n          lastPoint.current[1] - offset\n        );\n        context.lineTo(newPoint[0] - offset, newPoint[1] - offset);\n        context.stroke();\n      }\n      context.globalAlpha = 1;\n      context.beginPath();\n\n      lastPoint.current = newPoint;\n    },\n    [strokeWidth, lastPoint]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Marker\", startStroke, continueStroke, cursor };\n}\n","import { useCallback } from \"react\";\nimport tinycolor from \"tinycolor2\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseAirbrushProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useAirbrush({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseAirbrushProps): ToolHandlers {\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"darken\";\n      context.lineWidth = strokeWidth;\n      context.lineJoin = context.lineCap = \"round\";\n      context.strokeStyle = color;\n      context.shadowBlur = strokeWidth * 0.5;\n      context.shadowColor = tinycolor(color)\n        .setAlpha(0.5)\n        .toPercentageRgbString();\n      console.log(context.shadowColor);\n      context.moveTo(point[0], point[1]);\n      context.beginPath();\n    },\n    [color, strokeWidth]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n    },\n    []\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Airbrush\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { useCallback, useRef } from \"react\";\nimport tinycolor from \"tinycolor2\";\n\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nexport interface UseShadingProps {\n  color?: string;\n  neighbourColor?: string;\n  neighbourStrokeWidth?: number;\n  distanceThreshold?: number;\n  spreadFactor?: number;\n}\n\nexport function useShadingBrush({\n  color = \"#000000\",\n  neighbourColor,\n  distanceThreshold = 40,\n  neighbourStrokeWidth = 1,\n  spreadFactor = 0.9,\n}: UseShadingProps): ToolHandlers {\n  neighbourColor ||= tinycolor(color).setAlpha(0.2).toPercentageRgbString();\n  const points = useRef<Array<Point>>([]);\n  const threshold = distanceThreshold * distanceThreshold;\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"darken\";\n      context.lineWidth = 1;\n      context.lineJoin = context.lineCap = \"round\";\n      points.current = [point];\n    },\n    []\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      context.strokeStyle = color;\n      context.lineWidth = 1;\n\n      points.current.push(newPoint);\n      context.beginPath();\n      const [prevX, prevY] = points.current[points.current.length - 2];\n      context.moveTo(prevX, prevY);\n      context.lineTo(...newPoint);\n      context.stroke();\n      context.lineWidth = neighbourStrokeWidth;\n\n      for (const point of points.current) {\n        const dx = point[0] - newPoint[0];\n        const dy = point[1] - newPoint[1];\n        const distance = dx * dx + dy * dy;\n\n        if (distance < threshold && Math.random() > distance / threshold) {\n          context.beginPath();\n          context.strokeStyle = neighbourColor as string;\n          context.moveTo(\n            newPoint[0] + dx * spreadFactor,\n            newPoint[1] + dy * spreadFactor\n          );\n          context.lineTo(\n            point[0] - dx * spreadFactor,\n            point[1] - dy * spreadFactor\n          );\n          context.stroke();\n        }\n      }\n    },\n    [neighbourStrokeWidth, color, spreadFactor, threshold, neighbourColor]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n  const cursor = \"crosshair\";\n\n  return { name: \"Shading\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { Point } from \"../../utils/pointUtils\";\n\nlet spareRandom: number | null = null;\n\n// https://gist.github.com/bluesmoon/7925696\nfunction normalRandom() {\n  let val, u, v, s, mul;\n  if (spareRandom !== null) {\n    val = spareRandom;\n    spareRandom = null;\n  } else {\n    do {\n      u = Math.random() * 2 - 1;\n      v = Math.random() * 2 - 1;\n      s = u * u + v * v;\n    } while (s === 0 || s >= 1);\n    mul = Math.sqrt((-2 * Math.log(s)) / s);\n    val = u * mul;\n    spareRandom = v * mul;\n  }\n  return val;\n}\nexport function makePolygon(\n  centre: Point,\n  sides: number,\n  radius: number\n): Array<Point> {\n  const increment = (Math.PI * 2) / sides;\n  const result: Array<Point> = [];\n  for (let i = 1; i <= sides; i++) {\n    result.push([\n      radius * Math.cos(increment * i) + centre[0],\n      radius * Math.sin(increment * i) + centre[1],\n    ]);\n  }\n  return result;\n}\n\nexport function deformPolygon(\n  points: Array<Point>,\n  depth: number,\n  variance: number,\n  vdiv: number\n): Array<Point> {\n  const newPoints: Array<Point> = [];\n  for (let i = 0; i < points.length; i++) {\n    const currentPoint = points[i];\n    const nextPoint = points[(i + 1) % points.length];\n    newPoints.push(currentPoint);\n    newPoints.push(\n      ...subdivideVertex(currentPoint, nextPoint, depth, variance, vdiv)\n    );\n  }\n  return newPoints;\n}\n\nfunction subdivideVertex(\n  currentPoint: Point,\n  nextPoint: Point,\n  depth: number,\n  variance: number,\n  vdiv: number\n): Array<Point> {\n  if (depth < 0) {\n    return [];\n  }\n  //   Find the midpoint\n  const midX = (currentPoint[0] + nextPoint[0]) / 2;\n  const midY = (currentPoint[1] + nextPoint[1]) / 2;\n\n  //   Nudge the midpoint\n  const newMidpoint: Point = [\n    midX + normalRandom() * variance,\n    midY + normalRandom() * variance,\n  ];\n\n  const newPoints = subdivideVertex(\n    currentPoint,\n    newMidpoint,\n    depth - 1,\n    variance / vdiv,\n    vdiv\n  );\n\n  newPoints.push(newMidpoint);\n  newPoints.push(\n    ...subdivideVertex(newMidpoint, nextPoint, depth - 1, variance / vdiv, vdiv)\n  );\n  return newPoints;\n}\n\nexport function getSplodge(\n  point: Point,\n  sides: number,\n  radius: number\n): Array<Point> {\n  return deformPolygon(makePolygon(point, sides, radius), 5, radius / 10, 2);\n}\n\nexport function splodgeAtPoint(\n  point: Point,\n  context: CanvasRenderingContext2D,\n  width: number\n): void {\n  context.beginPath();\n  getSplodge(point, Math.round(width / 5), width).forEach((point) => {\n    context.lineTo(...point);\n  });\n  context.closePath();\n  context.fill();\n}\n\nexport function splodgeTrail(\n  points: Array<Point>,\n  width: number,\n  trail: number,\n  context: CanvasRenderingContext2D\n): void {\n  const count = Math.min(trail, points.length / 3);\n  for (let i = 0; i < count; i++) {\n    context.globalAlpha = 0.01 - (0.009 / count) * i;\n    splodgeAtPoint(\n      points[points.length - i * 3 - 1],\n      context,\n      width + (width / count) * i\n    );\n  }\n  context.globalAlpha = 0.1;\n}\n","import { useCallback, useRef } from \"react\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nimport { splodgeTrail } from \"./watercolor\";\n\nexport interface UseWatercolorProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useWatercolor({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseWatercolorProps): ToolHandlers {\n  const points = useRef<Array<Point>>([]);\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.fillStyle = color;\n      context.shadowColor = color;\n      context.globalAlpha = 0.01;\n      points.current = [point];\n      splodgeTrail(points.current, strokeWidth * 1.1, 1, context);\n    },\n    [color, strokeWidth]\n  );\n\n  const endStroke = useCallback(() => {\n    points.current = [];\n  }, []);\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      points.current.push(point);\n      splodgeTrail(points.current, strokeWidth, 5, context);\n    },\n    [strokeWidth]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Watercolor\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { useCallback } from \"react\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseEraserProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useEraser({ strokeWidth = 25 }: UseEraserProps): ToolHandlers {\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"source-over\";\n\n      context.lineWidth = strokeWidth;\n      context.strokeStyle = \"#ffffff\";\n      context.lineJoin = context.lineCap = \"round\";\n      context.moveTo(point[0], point[1]);\n      context.beginPath();\n    },\n    [strokeWidth]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n    },\n    []\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Eraser\", startStroke, continueStroke, cursor };\n}\n","import { useCallback } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UsePencilProps {\n  color?: string;\n  strokeWidth?: number;\n  opacity?: number;\n}\n\nexport function usePencil({\n  color = \"#2c2c2c\",\n  strokeWidth = 3,\n  opacity = 0.8,\n}: UsePencilProps): ToolHandlers {\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = opacity;\n      context.lineWidth = strokeWidth;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.globalCompositeOperation = \"multiply\";\n      context.moveTo(point[0], point[1]);\n      context.beginPath();\n    },\n    [color, strokeWidth, opacity]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      // Add some texture by varying the line width slightly\n      const variation = (Math.random() - 0.5) * 0.5;\n      context.lineWidth = strokeWidth + variation;\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n    },\n    [strokeWidth]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Pencil\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseCharcoalProps {\n  color?: string;\n  strokeWidth?: number;\n  roughness?: number;\n}\n\nexport function useCharcoal({\n  color = \"#1a1a1a\",\n  strokeWidth = 15,\n  roughness = 0.7,\n}: UseCharcoalProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = 0.6;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.globalCompositeOperation = \"multiply\";\n      lastPoint.current = point;\n    },\n    [color]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      // Create multiple strokes for texture\n      const bristleCount = Math.floor(strokeWidth / 3);\n      for (let i = 0; i < bristleCount; i++) {\n        context.beginPath();\n        \n        // Random offset for each bristle\n        const offsetX = (Math.random() - 0.5) * strokeWidth * roughness;\n        const offsetY = (Math.random() - 0.5) * strokeWidth * roughness;\n        \n        // Vary line width for each bristle\n        context.lineWidth = Math.random() * 3 + 1;\n        \n        context.moveTo(\n          lastPoint.current[0] + offsetX,\n          lastPoint.current[1] + offsetY\n        );\n        context.lineTo(point[0] + offsetX, point[1] + offsetY);\n        context.stroke();\n      }\n\n      lastPoint.current = point;\n    },\n    [strokeWidth, roughness]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Charcoal\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseCalligraphyProps {\n  color?: string;\n  strokeWidth?: number;\n  angle?: number;\n}\n\nexport function useCalligraphy({\n  color = \"#000000\",\n  strokeWidth = 20,\n  angle = 45,\n}: UseCalligraphyProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n  const lastTime = useRef<number>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      lastPoint.current = point;\n      lastTime.current = Date.now();\n    },\n    [color]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current || !lastTime.current) {\n        lastPoint.current = point;\n        lastTime.current = Date.now();\n        return;\n      }\n\n      const currentTime = Date.now();\n      const timeDelta = Math.max(currentTime - lastTime.current, 1);\n      \n      // Calculate speed and direction\n      const dx = point[0] - lastPoint.current[0];\n      const dy = point[1] - lastPoint.current[1];\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const speed = distance / timeDelta;\n      \n      // Calculate stroke angle relative to pen angle\n      const strokeAngle = Math.atan2(dy, dx);\n      const angleDiff = Math.abs(strokeAngle - (angle * Math.PI / 180));\n      const normalizedAngle = Math.min(angleDiff, Math.PI - angleDiff);\n      \n      // Vary width based on angle and speed\n      const angleMultiplier = Math.sin(normalizedAngle) * 0.8 + 0.2;\n      const speedMultiplier = Math.max(0.3, 1 - speed * 0.02);\n      const currentWidth = strokeWidth * angleMultiplier * speedMultiplier;\n\n      context.beginPath();\n      context.lineWidth = currentWidth;\n      context.moveTo(lastPoint.current[0], lastPoint.current[1]);\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n\n      lastPoint.current = point;\n      lastTime.current = currentTime;\n    },\n    [strokeWidth, angle]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Calligraphy\", startStroke, continueStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseInkPenProps {\n  color?: string;\n  strokeWidth?: number;\n  flow?: number;\n}\n\nexport function useInkPen({\n  color = \"#000080\",\n  strokeWidth = 4,\n  flow = 0.9,\n}: UseInkPenProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n  const pressure = useRef<number>(1);\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = flow;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.shadowColor = color;\n      context.shadowBlur = 1;\n      lastPoint.current = point;\n      pressure.current = 0.5;\n    },\n    [color, flow]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      // Simulate pressure based on speed\n      const dx = point[0] - lastPoint.current[0];\n      const dy = point[1] - lastPoint.current[1];\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      // Smooth pressure changes\n      const targetPressure = Math.max(0.3, Math.min(1, 1 - distance * 0.01));\n      pressure.current = pressure.current * 0.7 + targetPressure * 0.3;\n\n      const currentWidth = strokeWidth * pressure.current;\n\n      context.beginPath();\n      context.lineWidth = currentWidth;\n      \n      // Use quadratic curves for smoother lines\n      const midX = (lastPoint.current[0] + point[0]) / 2;\n      const midY = (lastPoint.current[1] + point[1]) / 2;\n      \n      context.moveTo(lastPoint.current[0], lastPoint.current[1]);\n      context.quadraticCurveTo(lastPoint.current[0], lastPoint.current[1], midX, midY);\n      context.stroke();\n\n      lastPoint.current = point;\n    },\n    [strokeWidth]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.shadowBlur = 0;\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Ink Pen\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\nimport tinycolor from \"tinycolor2\";\n\nexport interface UseOilPaintProps {\n  color?: string;\n  strokeWidth?: number;\n  blending?: number;\n}\n\nexport function useOilPaint({\n  color = \"#8B4513\",\n  strokeWidth = 25,\n  blending = 0.6,\n}: UseOilPaintProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = 0.8;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.globalCompositeOperation = \"source-over\";\n      lastPoint.current = point;\n    },\n    [color]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      // Create multiple brush strokes with slight variations\n      const brushStrokes = 5;\n      for (let i = 0; i < brushStrokes; i++) {\n        context.beginPath();\n        \n        // Vary the color slightly for each stroke\n        const baseColor = tinycolor(color);\n        const variation = (Math.random() - 0.5) * 20;\n        const variedColor = baseColor.lighten(variation).toString();\n        \n        context.strokeStyle = variedColor;\n        context.lineWidth = strokeWidth + (Math.random() - 0.5) * 4;\n        \n        // Add random offset for texture\n        const offsetX = (Math.random() - 0.5) * strokeWidth * 0.3;\n        const offsetY = (Math.random() - 0.5) * strokeWidth * 0.3;\n        \n        context.moveTo(\n          lastPoint.current[0] + offsetX,\n          lastPoint.current[1] + offsetY\n        );\n        context.lineTo(point[0] + offsetX, point[1] + offsetY);\n        \n        // Use different blend modes for some strokes\n        if (i > 2) {\n          context.globalCompositeOperation = \"multiply\";\n          context.globalAlpha = blending * 0.5;\n        } else {\n          context.globalCompositeOperation = \"source-over\";\n          context.globalAlpha = 0.8;\n        }\n        \n        context.stroke();\n      }\n\n      lastPoint.current = point;\n    },\n    [color, strokeWidth, blending]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Oil Paint\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseAcrylicProps {\n  color?: string;\n  strokeWidth?: number;\n  opacity?: number;\n}\n\nexport function useAcrylic({\n  color = \"#FF6B35\",\n  strokeWidth = 20,\n  opacity = 0.9,\n}: UseAcrylicProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = opacity;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.globalCompositeOperation = \"source-over\";\n      lastPoint.current = point;\n    },\n    [color, opacity]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      // Create a solid, vibrant stroke with slight texture\n      context.beginPath();\n      context.lineWidth = strokeWidth;\n      \n      // Add slight texture variation\n      const textureVariation = (Math.random() - 0.5) * 2;\n      context.lineWidth = Math.max(1, strokeWidth + textureVariation);\n      \n      // Use bezier curves for smoother application\n      const controlPoint1X = lastPoint.current[0] + (point[0] - lastPoint.current[0]) * 0.3;\n      const controlPoint1Y = lastPoint.current[1] + (point[1] - lastPoint.current[1]) * 0.3;\n      const controlPoint2X = lastPoint.current[0] + (point[0] - lastPoint.current[0]) * 0.7;\n      const controlPoint2Y = lastPoint.current[1] + (point[1] - lastPoint.current[1]) * 0.7;\n      \n      context.moveTo(lastPoint.current[0], lastPoint.current[1]);\n      context.bezierCurveTo(\n        controlPoint1X, controlPoint1Y,\n        controlPoint2X, controlPoint2Y,\n        point[0], point[1]\n      );\n      context.stroke();\n\n      // Add some paint buildup effect\n      if (Math.random() > 0.8) {\n        context.beginPath();\n        context.globalAlpha = opacity * 0.3;\n        context.lineWidth = strokeWidth * 0.6;\n        context.moveTo(lastPoint.current[0], lastPoint.current[1]);\n        context.lineTo(point[0], point[1]);\n        context.stroke();\n        context.globalAlpha = opacity;\n      }\n\n      lastPoint.current = point;\n    },\n    [strokeWidth, opacity]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Acrylic\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseCrayonProps {\n  color?: string;\n  strokeWidth?: number;\n  pressure?: number;\n}\n\nexport function useCrayon({\n  color = \"#DC143C\",\n  strokeWidth = 12,\n  pressure = 0.6,\n}: UseCrayonProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalAlpha = pressure;\n      context.strokeStyle = color;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.globalCompositeOperation = \"multiply\";\n      lastPoint.current = point;\n    },\n    [color, pressure]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      // Create waxy texture with multiple overlapping strokes\n      const textureStrokes = 8;\n      for (let i = 0; i < textureStrokes; i++) {\n        context.beginPath();\n        \n        // Random positioning for texture\n        const offsetRadius = strokeWidth * 0.4;\n        const angle = (i / textureStrokes) * Math.PI * 2;\n        const offsetX = Math.cos(angle) * offsetRadius * Math.random();\n        const offsetY = Math.sin(angle) * offsetRadius * Math.random();\n        \n        // Vary the stroke width for texture\n        context.lineWidth = Math.max(1, strokeWidth * (0.3 + Math.random() * 0.7));\n        \n        // Vary opacity for buildup effect\n        context.globalAlpha = pressure * (0.2 + Math.random() * 0.6);\n        \n        context.moveTo(\n          lastPoint.current[0] + offsetX,\n          lastPoint.current[1] + offsetY\n        );\n        context.lineTo(point[0] + offsetX, point[1] + offsetY);\n        context.stroke();\n      }\n\n      lastPoint.current = point;\n    },\n    [strokeWidth, pressure]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Crayon\", startStroke, continueStroke, endStroke, cursor };\n} ","import { useCallback, useRef } from \"react\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport interface UseSmudgeProps {\n  strokeWidth?: number;\n  strength?: number;\n}\n\nexport function useSmudge({\n  strokeWidth = 30,\n  strength = 0.8,\n}: UseSmudgeProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n  const canvas = useRef<HTMLCanvasElement>();\n  const sourceImageData = useRef<ImageData>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      lastPoint.current = point;\n      canvas.current = context.canvas;\n      \n      // Capture the area around the starting point\n      const radius = strokeWidth;\n      const x = Math.max(0, point[0] - radius);\n      const y = Math.max(0, point[1] - radius);\n      const width = Math.min(canvas.current.width - x, radius * 2);\n      const height = Math.min(canvas.current.height - y, radius * 2);\n      \n      if (width > 0 && height > 0) {\n        sourceImageData.current = context.getImageData(x, y, width, height);\n      }\n    },\n    [strokeWidth]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current || !sourceImageData.current || !canvas.current) {\n        lastPoint.current = point;\n        return;\n      }\n\n      const dx = point[0] - lastPoint.current[0];\n      const dy = point[1] - lastPoint.current[1];\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < 2) return; // Avoid too many small movements\n\n      // Create a temporary canvas for the smudge effect\n      const tempCanvas = document.createElement('canvas');\n      const tempContext = tempCanvas.getContext('2d');\n      if (!tempContext) return;\n\n      tempCanvas.width = strokeWidth * 2;\n      tempCanvas.height = strokeWidth * 2;\n\n      // Draw the source image data\n      tempContext.putImageData(sourceImageData.current, 0, 0);\n\n      // Apply the smudge by stretching the image\n      const stretchFactor = Math.min(distance * 0.1, strokeWidth * 0.5);\n      \n      context.globalAlpha = strength;\n      context.globalCompositeOperation = \"source-over\";\n      \n      // Draw multiple stretched versions for smooth blending\n      for (let i = 0; i < 5; i++) {\n        const factor = (i + 1) / 5;\n        const offsetX = dx * factor * 0.3;\n        const offsetY = dy * factor * 0.3;\n        \n        context.drawImage(\n          tempCanvas,\n          point[0] - strokeWidth + offsetX,\n          point[1] - strokeWidth + offsetY,\n          strokeWidth * 2,\n          strokeWidth * 2\n        );\n      }\n\n      // Update source image data for next stroke\n      const radius = strokeWidth;\n      const x = Math.max(0, point[0] - radius);\n      const y = Math.max(0, point[1] - radius);\n      const width = Math.min(canvas.current.width - x, radius * 2);\n      const height = Math.min(canvas.current.height - y, radius * 2);\n      \n      if (width > 0 && height > 0) {\n        sourceImageData.current = context.getImageData(x, y, width, height);\n      }\n\n      lastPoint.current = point;\n    },\n    [strokeWidth, strength]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalAlpha = 1;\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Smudge\", startStroke, continueStroke, endStroke, cursor };\n} ","export type Point = [number, number];\n\nexport const getTouchPoint = (event: React.TouchEvent): Point => {\n  if (!event.currentTarget) {\n    return [0, 0];\n  }\n  const rect = event.currentTarget.getBoundingClientRect();\n  const touch = event.targetTouches[0];\n  return [touch.clientX - rect.left, touch.clientY - rect.top];\n};\n\nexport const getMousePoint = (event: React.MouseEvent): Point => [\n  event.nativeEvent.offsetX,\n  event.nativeEvent.offsetY,\n];\n\nconst BUTTON = 0b01;\nexport const mouseButtonIsDown = (buttons: number): boolean =>\n  (BUTTON & buttons) === BUTTON;\n","import React, {\n  ForwardedRef,\n  forwardRef,\n  useCallback,\n  useImperativeHandle,\n  useState,\n  useEffect,\n} from \"react\";\n\nimport { History } from \"../history\";\n\nimport {\n  getMousePoint,\n  getTouchPoint,\n  mouseButtonIsDown,\n  Point,\n} from \"../utils/pointUtils\";\n\nexport interface ArtboardProps\n  extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  tool: ToolHandlers;\n  history?: History;\n  onStartStroke?: (point: Point) => void;\n  onContinueStroke?: (point: Point) => void;\n  onEndStroke?: () => void;\n}\n\nexport interface ArtboardRef {\n  download: (filename?: string, type?: string) => void;\n  getImageAsDataUri: (type?: string) => string | undefined;\n  clear: () => void;\n  context?: CanvasRenderingContext2D | null;\n}\n\nexport interface ToolHandlers {\n  name: string;\n  startStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\n  continueStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\n  endStroke?: (context: CanvasRenderingContext2D) => void;\n  cursor?: string;\n}\n\nexport const Artboard = forwardRef(function Artboard(\n  {\n    tool,\n    style,\n    history,\n    onStartStroke,\n    onContinueStroke,\n    onEndStroke,\n    ...props\n  }: ArtboardProps,\n  ref: ForwardedRef<ArtboardRef>\n) {\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>();\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\n  const [drawing, setDrawing] = useState(false);\n\n  const startStroke = useCallback(\n    (point: Point) => {\n      if (!context) {\n        return;\n      }\n      context.save();\n      setDrawing(true);\n      tool.startStroke?.(point, context);\n      onStartStroke?.(point);\n    },\n    [tool, context, onStartStroke]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point) => {\n      if (!context) {\n        return;\n      }\n      tool.continueStroke?.(newPoint, context);\n      onContinueStroke?.(newPoint);\n    },\n    [tool, context, onContinueStroke]\n  );\n\n  const endStroke = useCallback(() => {\n    setDrawing(false);\n    if (context) {\n      tool.endStroke?.(context);\n      onEndStroke?.();\n      context.restore();\n      if (canvas && history) {\n        history.pushState(canvas);\n      }\n    }\n  }, [tool, context, canvas, history, onEndStroke]);\n\n  const mouseMove = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      if (!drawing) {\n        return;\n      }\n      continueStroke(getMousePoint(event));\n    },\n    [continueStroke, drawing]\n  );\n\n  const touchMove = useCallback(\n    (event: React.TouchEvent) => {\n      if (!drawing) {\n        return;\n      }\n      continueStroke(getTouchPoint(event));\n    },\n    [continueStroke, drawing]\n  );\n\n  const mouseDown = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      if (drawing) {\n        return;\n      }\n      event.preventDefault();\n      startStroke(getMousePoint(event));\n    },\n    [drawing, startStroke]\n  );\n\n  const touchStart = useCallback(\n    (event: React.TouchEvent) => {\n      if (drawing) {\n        return;\n      }\n      startStroke(getTouchPoint(event));\n    },\n    [drawing, startStroke]\n  );\n\n  const clear = useCallback(() => {\n    if (!context || !canvas) {\n      return;\n    }\n    context.save();\n    context.fillStyle = \"#ffffff\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.restore();\n    if (canvas && history) {\n      history.pushState(canvas);\n    }\n  }, [context, canvas, history]);\n\n  const gotRef = useCallback(\n    (canvasRef: HTMLCanvasElement) => {\n      if (!canvasRef) {\n        return;\n      }\n      canvasRef.width = canvasRef.offsetWidth;\n      canvasRef.height = canvasRef.offsetHeight;\n      const ctx = canvasRef.getContext(\"2d\");\n      setCanvas(canvasRef);\n      setContext(ctx);\n      if (!ctx) {\n        return;\n      }\n      ctx.fillStyle = \"#ffffff\";\n      ctx.fillRect(0, 0, canvasRef.width, canvasRef.height);\n      ctx.fillStyle = \"transparent\";\n      if (history) {\n        history.setContext(ctx);\n        history.pushState(canvasRef);\n      }\n    },\n    [history]\n  );\n\n  const mouseEnter = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      // If mouse button is down but we're not drawing, start a new stroke\n      if (mouseButtonIsDown(event.buttons) && !drawing) {\n        mouseDown(event);\n      }\n    },\n    [drawing, mouseDown]\n  );\n\n  const mouseLeave = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      // Don't end the stroke when leaving the canvas - let the global mouse handlers manage this\n      // This allows continuous drawing when moving outside and back into the canvas\n    },\n    []\n  );\n\n  // Add global mouse event listeners for better drawing experience\n  useEffect(() => {\n    if (!drawing || !canvas) {\n      return;\n    }\n\n    const handleGlobalMouseMove = (event: MouseEvent) => {\n      if (!drawing) {\n        return;\n      }\n      \n      const rect = canvas.getBoundingClientRect();\n      const point: Point = [\n        event.clientX - rect.left,\n        event.clientY - rect.top\n      ];\n      \n      // Only process global mouse events when outside the canvas bounds\n      // This prevents double processing when drawing inside the canvas\n      const isOutsideCanvas = point[0] < 0 || point[0] > canvas.width || \n                              point[1] < 0 || point[1] > canvas.height;\n      \n      if (isOutsideCanvas && \n          point[0] >= -50 && point[0] <= canvas.width + 50 && \n          point[1] >= -50 && point[1] <= canvas.height + 50) {\n        continueStroke(point);\n      }\n    };\n\n    const handleGlobalMouseUp = () => {\n      if (drawing) {\n        endStroke();\n      }\n    };\n\n    document.addEventListener('mousemove', handleGlobalMouseMove);\n    document.addEventListener('mouseup', handleGlobalMouseUp);\n\n    return () => {\n      document.removeEventListener('mousemove', handleGlobalMouseMove);\n      document.removeEventListener('mouseup', handleGlobalMouseUp);\n    };\n  }, [drawing, canvas, continueStroke, endStroke]);\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      download: (filename = \"image.png\", type?: string) => {\n        if (!canvas) {\n          return;\n        }\n        const a = document.createElement(\"a\");\n        a.href = canvas.toDataURL(type);\n        a.download = filename;\n        a.click();\n      },\n      clear,\n      getImageAsDataUri: (type?: string) => canvas?.toDataURL(type),\n      context,\n    }),\n    [canvas, context, clear]\n  );\n\n  return (\n    <canvas\n      style={{ cursor: tool?.cursor, touchAction: \"none\", ...style }}\n      onTouchStart={touchStart}\n      onMouseDown={mouseDown}\n      onMouseEnter={mouseEnter}\n      onMouseMove={drawing ? mouseMove : undefined}\n      onTouchMove={drawing ? touchMove : undefined}\n      onMouseUp={endStroke}\n      onMouseOut={mouseLeave}\n      onTouchEnd={endStroke}\n      ref={gotRef}\n      {...props}\n    />\n  );\n});\n","import { useCallback, useMemo, useRef, useState } from \"react\";\n\nasync function applyImage(context: CanvasRenderingContext2D, blob: Blob) {\n  const img = new Image();\n  img.onload = () => {\n    context.canvas.width = img.width;\n    context.canvas.height = img.height;\n    context.drawImage(img, 0, 0);\n    URL.revokeObjectURL(img.src);\n  };\n  img.src = URL.createObjectURL(blob);\n}\n\nexport interface History {\n  setContext: (context: CanvasRenderingContext2D) => void;\n  pushState: (canvas: HTMLCanvasElement) => Promise<boolean>;\n}\nexport interface HistoryHook {\n  history: History;\n\n  undo: () => Promise<boolean>;\n  redo: () => Promise<boolean>;\n  clear: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n}\n\nexport function useHistory(size?: number): HistoryHook {\n  const stack = useRef<Array<Blob>>([]);\n  const crs = useRef(0);\n  const [context, setContext] = useState<CanvasRenderingContext2D>();\n  const [canUndo, setCanUndo] = useState(false);\n  const [canRedo, setCanRedo] = useState(false);\n\n  const pushState = useCallback(\n    async (canvas: HTMLCanvasElement) => {\n      const undoCursor = crs.current;\n      if (!context) {\n        console.error(\"Context not initialised\");\n        return false;\n      }\n      if (undoCursor !== 0) {\n        stack.current = stack.current.slice(0, -undoCursor);\n        crs.current = 0;\n      }\n      const blob = await new Promise<Blob | null>((resolve) =>\n        canvas.toBlob(resolve)\n      );\n      if (blob) {\n        stack.current.push(blob);\n      }\n      if (size && stack.current.length > size) {\n        stack.current = stack.current.slice(-size);\n      }\n      setCanUndo(stack.current.length > 1);\n      setCanRedo(false);\n      return true;\n    },\n    [crs, stack, context]\n  );\n  const undo = useCallback(async () => {\n    const undoCursor = crs.current;\n\n    if (!context) {\n      console.error(\"Context not initialised\");\n      return false;\n    }\n    if (undoCursor + 1 >= stack.current.length) {\n      console.log(\"nope\");\n      return false;\n    }\n\n    await applyImage(\n      context,\n      stack.current[stack.current.length - (undoCursor + 2)]\n    );\n    crs.current++;\n    setCanUndo(crs.current + 1 < stack.current.length);\n    setCanRedo(true);\n    return true;\n  }, [crs, stack, context]);\n\n  const redo = useCallback(async () => {\n    const undoCursor = crs.current;\n\n    if (!context) {\n      console.error(\"Context not initialised\");\n      return false;\n    }\n    if (undoCursor <= 0) {\n      return false;\n    }\n\n    await applyImage(context, stack.current[stack.current.length - undoCursor]);\n    crs.current--;\n    setCanUndo(crs.current + 1 < stack.current.length);\n    setCanRedo(crs.current > 0);\n    return true;\n  }, [stack, crs, context]);\n\n  const clear = useCallback(() => {\n    stack.current = [];\n  }, [stack]);\n\n  const history = useMemo<History>(\n    () => ({\n      setContext: (context: CanvasRenderingContext2D) => {\n        setContext(context);\n      },\n      pushState,\n    }),\n    [setContext, pushState]\n  );\n\n  return { history, undo, redo, clear, canUndo, canRedo };\n}\n"],"names":["varyColour","sourceColour","varyBrightness","amount","Math","round","random","alpha","tinycolor","darken","setAlpha","toPercentageRgbString","rotatePoint","distance","angle","origin","cos","sin","circleCursor","diameter","btoa","circleSVG","circleDataUri","useBrush","color","strokeWidth","brush","setBrush","useState","currentAngle","useRef","lastPoint","name","startStroke","useCallback","point","current","undefined","colour","bristleCount","gap","i","push","thickness","makeBrush","continueStroke","newPoint","context","newAngle","destination","oldAngle","bearing","atan2","PI","getBearing","angleA","angleB","twoPi","diff","angleDiff","getNewAngle","bristles","forEach","bristle","beginPath","controlPoint","moveTo","strokeStyle","lineWidth","lineCap","lineJoin","shadowColor","shadowBlur","quadraticCurveTo","lineTo","stroke","strokeBristle","drawStroke","cursor","useMarker","offset","globalAlpha","useAirbrush","globalCompositeOperation","console","log","endStroke","useShadingBrush","neighbourColor","distanceThreshold","neighbourStrokeWidth","spreadFactor","points","threshold","prevX","prevY","length","dx","dy","spareRandom","normalRandom","val","u","v","s","mul","sqrt","subdivideVertex","currentPoint","nextPoint","depth","variance","vdiv","midY","newMidpoint","newPoints","splodgeAtPoint","width","sides","radius","deformPolygon","centre","increment","result","makePolygon","getSplodge","closePath","fill","splodgeTrail","trail","count","min","useWatercolor","fillStyle","useEraser","usePencil","opacity","variation","useCharcoal","roughness","floor","offsetX","offsetY","useCalligraphy","lastTime","Date","now","currentTime","timeDelta","max","speed","strokeAngle","abs","normalizedAngle","angleMultiplier","speedMultiplier","currentWidth","useInkPen","flow","pressure","targetPressure","midX","useOilPaint","blending","baseColor","variedColor","lighten","toString","useAcrylic","textureVariation","controlPoint1X","controlPoint1Y","controlPoint2X","controlPoint2Y","bezierCurveTo","useCrayon","offsetRadius","useSmudge","strength","canvas","sourceImageData","x","y","height","getImageData","tempCanvas","document","createElement","tempContext","getContext","putImageData","factor","drawImage","getTouchPoint","event","currentTarget","rect","getBoundingClientRect","touch","targetTouches","clientX","left","clientY","top","getMousePoint","nativeEvent","mouseButtonIsDown","buttons","Artboard","forwardRef","ref","tool","style","history","onStartStroke","onContinueStroke","onEndStroke","props","setContext","setCanvas","drawing","setDrawing","save","restore","pushState","mouseMove","touchMove","mouseDown","preventDefault","touchStart","clear","fillRect","gotRef","canvasRef","offsetWidth","offsetHeight","ctx","mouseEnter","mouseLeave","useEffect","handleGlobalMouseMove","handleGlobalMouseUp","addEventListener","removeEventListener","useImperativeHandle","download","filename","type","a","href","toDataURL","click","getImageAsDataUri","_jsx","touchAction","onTouchStart","onMouseDown","onMouseEnter","onMouseMove","onTouchMove","onMouseUp","onMouseOut","onTouchEnd","async","applyImage","blob","img","Image","onload","URL","revokeObjectURL","src","createObjectURL","useHistory","size","stack","crs","canUndo","setCanUndo","canRedo","setCanRedo","undoCursor","error","slice","Promise","resolve","toBlob","undo","redo","useMemo"],"mappings":"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"}