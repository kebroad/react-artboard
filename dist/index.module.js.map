{"version":3,"file":"index.module.js","sources":["../src/tools/brush/brushHelpers.ts","../src/utils/cursors.ts","../src/tools/brush/useBrush.ts","../src/tools/marker/useMarker.ts","../src/tools/airbrush/useAirbrush.ts","../src/tools/shading/useShadingBrush.ts","../src/tools/watercolor/watercolor.ts","../src/tools/watercolor/useWatercolor.ts","../src/tools/eraser/useEraser.ts","../src/utils/pointUtils.ts","../src/components/Artboard.tsx","../src/history.ts"],"sourcesContent":["import tinycolor from \"tinycolor2\";\nimport { Point } from \"../../utils/pointUtils\";\n\nexport function varyColour(\n  sourceColour: string,\n  varyBrightness: number\n): string {\n  const amount = Math.round(Math.random() * varyBrightness);\n  const alpha = 1 - Math.random() / 4;\n  const colour = tinycolor(sourceColour);\n  const varied = colour.darken(amount - varyBrightness / 2).setAlpha(alpha);\n  return varied.toPercentageRgbString();\n}\n\nexport interface Bristle {\n  distance: number;\n  thickness: number;\n  colour: string;\n}\n\nexport const rotatePoint = (\n  distance: number,\n  angle: number,\n  origin: Point\n): Point => [\n  origin[0] + distance * Math.cos(angle),\n  origin[1] + distance * Math.sin(angle),\n];\n\nexport const getBearing = (origin: Point, destination: Point): number =>\n  (Math.atan2(destination[1] - origin[1], destination[0] - origin[0]) -\n    Math.PI / 2) %\n  (Math.PI * 2);\n\nexport const getNewAngle = (\n  origin: Point,\n  destination: Point,\n  oldAngle?: number\n): number => {\n  const bearing = getBearing(origin, destination);\n  if (typeof oldAngle === \"undefined\") {\n    return bearing;\n  }\n  return oldAngle - angleDiff(oldAngle, bearing);\n};\n\nexport const angleDiff = (angleA: number, angleB: number): number => {\n  const twoPi = Math.PI * 2;\n  const diff =\n    ((angleA - (angleB > 0 ? angleB : angleB + twoPi) + Math.PI) % twoPi) -\n    Math.PI;\n  return diff < -Math.PI ? diff + twoPi : diff;\n};\n","export function circleSVG(diameter: number) {\n  return `<svg xmlns='http://www.w3.org/2000/svg' width='${diameter}' height='${diameter}' viewBox='0 0 ${diameter} ${diameter}'><circle r='${\n    diameter / 2\n  }' cy='${diameter / 2}' cx='${\n    diameter / 2\n  }' stroke-width='1' stroke='rgba(0,0,0,0.5)' fill='none'/></svg>`;\n}\n\nexport function circleDataUri(diameter: number) {\n  return `data:image/svg+xml;base64,${btoa(circleSVG(diameter))}`;\n}\n\nexport function circleCursor(diameter: number) {\n  return `url(${circleDataUri(diameter)}) ${diameter / 2} ${\n    diameter / 2\n  }, crosshair`;\n}\n","import { useCallback, useRef, useState } from \"react\";\n\nimport { Bristle, getNewAngle, rotatePoint, varyColour } from \"./brushHelpers\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\n\nexport type Brush = Array<Bristle>;\n\nfunction makeBrush(\n  strokeWidth: number,\n  colour: string,\n  varyBrightness: number\n): Brush {\n  const brush: Brush = [];\n  const bristleCount = Math.round(strokeWidth / 3);\n  const gap = strokeWidth / bristleCount;\n  for (let i = 0; i < bristleCount; i++) {\n    const distance =\n      i === 0 ? 0 : gap * i + (Math.random() * gap) / 2 - gap / 2;\n    brush.push({\n      distance,\n      thickness: Math.random() * 2 + 2,\n      colour: varyColour(colour, varyBrightness),\n    });\n  }\n  return brush;\n}\n\nconst strokeBristle = (\n  origin: Point,\n  destination: Point,\n  bristle: Bristle,\n  controlPoint: Point,\n  context: CanvasRenderingContext2D\n) => {\n  context.beginPath();\n  context.moveTo(origin[0], origin[1]);\n  context.strokeStyle = bristle.colour;\n  context.lineWidth = bristle.thickness;\n  context.lineCap = \"round\";\n  context.lineJoin = \"round\";\n  context.shadowColor = bristle.colour;\n  context.shadowBlur = bristle.thickness / 2;\n  context.quadraticCurveTo(\n    controlPoint[0],\n    controlPoint[1],\n    destination[0],\n    destination[1]\n  );\n  context.lineTo(destination[0], destination[1]);\n  context.stroke();\n};\n\nconst drawStroke = (\n  bristles: Brush,\n  origin: Point,\n  destination: Point,\n  oldAngle: number,\n  newAngle: number,\n  strokeWidth: number,\n  context: CanvasRenderingContext2D\n) => {\n  bristles.forEach((bristle) => {\n    context.beginPath();\n    const bristleOrigin = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      oldAngle,\n      origin\n    );\n\n    const bristleDestination = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      newAngle,\n      destination\n    );\n    const controlPoint = rotatePoint(\n      bristle.distance - strokeWidth / 2,\n      newAngle,\n      origin\n    );\n\n    strokeBristle(\n      bristleOrigin,\n      bristleDestination,\n      bristle,\n      controlPoint,\n      context\n    );\n  });\n};\n\nexport interface UseBrushProps {\n  color?: string;\n  strokeWidth?: number;\n  varyBrightness?: number;\n}\n\nexport function useBrush({\n  color = \"#000000\",\n  strokeWidth = 25,\n  varyBrightness = 5,\n}: UseBrushProps): ToolHandlers {\n  const [brush, setBrush] = useState<Brush>([]);\n  const currentAngle = useRef<number>();\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point) => {\n      currentAngle.current = undefined;\n      setBrush(makeBrush(strokeWidth, color, varyBrightness));\n      lastPoint.current = point;\n    },\n    [setBrush, strokeWidth, color, varyBrightness]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = newPoint;\n        return;\n      }\n      const newAngle = getNewAngle(\n        lastPoint.current,\n        newPoint,\n        currentAngle.current\n      );\n      if (typeof currentAngle.current === \"undefined\") {\n        currentAngle.current = newAngle % (Math.PI * 2);\n      }\n      drawStroke(\n        brush,\n        lastPoint.current,\n        newPoint,\n        currentAngle.current,\n        newAngle,\n        strokeWidth,\n        context\n      );\n      currentAngle.current = newAngle % (Math.PI * 2);\n      lastPoint.current = newPoint;\n    },\n    [brush, strokeWidth]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Paintbrush\", startStroke, continueStroke, cursor };\n}\n","import { useCallback, useRef } from \"react\";\n\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseMarkerProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useMarker({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseMarkerProps): ToolHandlers {\n  const lastPoint = useRef<Point>();\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineWidth = 3;\n      context.lineJoin = context.lineCap = \"round\";\n      lastPoint.current = point;\n      context.strokeStyle = color;\n    },\n    [color]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      if (!lastPoint.current) {\n        lastPoint.current = newPoint;\n        return;\n      }\n      if (\n        lastPoint.current[0] === newPoint[0] &&\n        lastPoint.current[1] === newPoint[1]\n      ) {\n        return;\n      }\n      context.beginPath();\n\n      for (let i = 0; i < strokeWidth; i += 2) {\n        const offset = Math.round(strokeWidth / 2 - i);\n        context.globalAlpha = (1 / strokeWidth) * (strokeWidth - i);\n        context.moveTo(\n          lastPoint.current[0] - offset,\n          lastPoint.current[1] - offset\n        );\n        context.lineTo(newPoint[0] - offset, newPoint[1] - offset);\n        context.stroke();\n      }\n      context.globalAlpha = 1;\n      context.beginPath();\n\n      lastPoint.current = newPoint;\n    },\n    [strokeWidth, lastPoint]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Marker\", startStroke, continueStroke, cursor };\n}\n","import { useCallback } from \"react\";\nimport tinycolor from \"tinycolor2\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseAirbrushProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useAirbrush({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseAirbrushProps): ToolHandlers {\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"darken\";\n      context.lineWidth = strokeWidth;\n      context.lineJoin = context.lineCap = \"round\";\n      context.strokeStyle = color;\n      context.shadowBlur = strokeWidth * 0.5;\n      context.shadowColor = tinycolor(color)\n        .setAlpha(0.5)\n        .toPercentageRgbString();\n      console.log(context.shadowColor);\n      context.moveTo(point[0], point[1]);\n      context.beginPath();\n    },\n    [color, strokeWidth]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n    },\n    []\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Airbrush\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { useCallback, useRef } from \"react\";\nimport tinycolor from \"tinycolor2\";\n\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nexport interface UseShadingProps {\n  color?: string;\n  neighbourColor?: string;\n  neighbourStrokeWidth?: number;\n  distanceThreshold?: number;\n  spreadFactor?: number;\n}\n\nexport function useShadingBrush({\n  color = \"#000000\",\n  neighbourColor,\n  distanceThreshold = 40,\n  neighbourStrokeWidth = 1,\n  spreadFactor = 0.9,\n}: UseShadingProps): ToolHandlers {\n  neighbourColor ||= tinycolor(color).setAlpha(0.2).toPercentageRgbString();\n  const points = useRef<Array<Point>>([]);\n  const threshold = distanceThreshold * distanceThreshold;\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"darken\";\n      context.lineWidth = 1;\n      context.lineJoin = context.lineCap = \"round\";\n      points.current = [point];\n    },\n    []\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\n      context.strokeStyle = color;\n      context.lineWidth = 1;\n\n      points.current.push(newPoint);\n      context.beginPath();\n      const [prevX, prevY] = points.current[points.current.length - 2];\n      context.moveTo(prevX, prevY);\n      context.lineTo(...newPoint);\n      context.stroke();\n      context.lineWidth = neighbourStrokeWidth;\n\n      for (const point of points.current) {\n        const dx = point[0] - newPoint[0];\n        const dy = point[1] - newPoint[1];\n        const distance = dx * dx + dy * dy;\n\n        if (distance < threshold && Math.random() > distance / threshold) {\n          context.beginPath();\n          context.strokeStyle = neighbourColor as string;\n          context.moveTo(\n            newPoint[0] + dx * spreadFactor,\n            newPoint[1] + dy * spreadFactor\n          );\n          context.lineTo(\n            point[0] - dx * spreadFactor,\n            point[1] - dy * spreadFactor\n          );\n          context.stroke();\n        }\n      }\n    },\n    [neighbourStrokeWidth, color, spreadFactor, threshold, neighbourColor]\n  );\n\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\n    context.globalCompositeOperation = \"source-over\";\n  }, []);\n  const cursor = \"crosshair\";\n\n  return { name: \"Shading\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { Point } from \"../../utils/pointUtils\";\n\nlet spareRandom: number | null = null;\n\n// https://gist.github.com/bluesmoon/7925696\nfunction normalRandom() {\n  let val, u, v, s, mul;\n  if (spareRandom !== null) {\n    val = spareRandom;\n    spareRandom = null;\n  } else {\n    do {\n      u = Math.random() * 2 - 1;\n      v = Math.random() * 2 - 1;\n      s = u * u + v * v;\n    } while (s === 0 || s >= 1);\n    mul = Math.sqrt((-2 * Math.log(s)) / s);\n    val = u * mul;\n    spareRandom = v * mul;\n  }\n  return val;\n}\nexport function makePolygon(\n  centre: Point,\n  sides: number,\n  radius: number\n): Array<Point> {\n  const increment = (Math.PI * 2) / sides;\n  const result: Array<Point> = [];\n  for (let i = 1; i <= sides; i++) {\n    result.push([\n      radius * Math.cos(increment * i) + centre[0],\n      radius * Math.sin(increment * i) + centre[1],\n    ]);\n  }\n  return result;\n}\n\nexport function deformPolygon(\n  points: Array<Point>,\n  depth: number,\n  variance: number,\n  vdiv: number\n): Array<Point> {\n  const newPoints: Array<Point> = [];\n  for (let i = 0; i < points.length; i++) {\n    const currentPoint = points[i];\n    const nextPoint = points[(i + 1) % points.length];\n    newPoints.push(currentPoint);\n    newPoints.push(\n      ...subdivideVertex(currentPoint, nextPoint, depth, variance, vdiv)\n    );\n  }\n  return newPoints;\n}\n\nfunction subdivideVertex(\n  currentPoint: Point,\n  nextPoint: Point,\n  depth: number,\n  variance: number,\n  vdiv: number\n): Array<Point> {\n  if (depth < 0) {\n    return [];\n  }\n  //   Find the midpoint\n  const midX = (currentPoint[0] + nextPoint[0]) / 2;\n  const midY = (currentPoint[1] + nextPoint[1]) / 2;\n\n  //   Nudge the midpoint\n  const newMidpoint: Point = [\n    midX + normalRandom() * variance,\n    midY + normalRandom() * variance,\n  ];\n\n  const newPoints = subdivideVertex(\n    currentPoint,\n    newMidpoint,\n    depth - 1,\n    variance / vdiv,\n    vdiv\n  );\n\n  newPoints.push(newMidpoint);\n  newPoints.push(\n    ...subdivideVertex(newMidpoint, nextPoint, depth - 1, variance / vdiv, vdiv)\n  );\n  return newPoints;\n}\n\nexport function getSplodge(\n  point: Point,\n  sides: number,\n  radius: number\n): Array<Point> {\n  return deformPolygon(makePolygon(point, sides, radius), 5, radius / 10, 2);\n}\n\nexport function splodgeAtPoint(\n  point: Point,\n  context: CanvasRenderingContext2D,\n  width: number\n): void {\n  context.beginPath();\n  getSplodge(point, Math.round(width / 5), width).forEach((point) => {\n    context.lineTo(...point);\n  });\n  context.closePath();\n  context.fill();\n}\n\nexport function splodgeTrail(\n  points: Array<Point>,\n  width: number,\n  trail: number,\n  context: CanvasRenderingContext2D\n): void {\n  const count = Math.min(trail, points.length / 3);\n  for (let i = 0; i < count; i++) {\n    context.globalAlpha = 0.01 - (0.009 / count) * i;\n    splodgeAtPoint(\n      points[points.length - i * 3 - 1],\n      context,\n      width + (width / count) * i\n    );\n  }\n  context.globalAlpha = 0.1;\n}\n","import { useCallback, useRef } from \"react\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nimport { splodgeTrail } from \"./watercolor\";\n\nexport interface UseWatercolorProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useWatercolor({\n  color = \"#000000\",\n  strokeWidth = 25,\n}: UseWatercolorProps): ToolHandlers {\n  const points = useRef<Array<Point>>([]);\n\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.fillStyle = color;\n      context.shadowColor = color;\n      context.globalAlpha = 0.01;\n      points.current = [point];\n      splodgeTrail(points.current, strokeWidth * 1.1, 1, context);\n    },\n    [color, strokeWidth]\n  );\n\n  const endStroke = useCallback(() => {\n    points.current = [];\n  }, []);\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      points.current.push(point);\n      splodgeTrail(points.current, strokeWidth, 5, context);\n    },\n    [strokeWidth]\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Watercolor\", startStroke, continueStroke, endStroke, cursor };\n}\n","import { useCallback } from \"react\";\nimport { ToolHandlers } from \"../../components/Artboard\";\nimport { Point } from \"../../utils/pointUtils\";\nimport { circleCursor } from \"../../utils/cursors\";\nexport interface UseEraserProps {\n  color?: string;\n  strokeWidth?: number;\n}\n\nexport function useEraser({ strokeWidth = 25 }: UseEraserProps): ToolHandlers {\n  const startStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.globalCompositeOperation = \"source-over\";\n\n      context.lineWidth = strokeWidth;\n      context.strokeStyle = \"#ffffff\";\n      context.lineJoin = context.lineCap = \"round\";\n      context.moveTo(point[0], point[1]);\n      context.beginPath();\n    },\n    [strokeWidth]\n  );\n\n  const continueStroke = useCallback(\n    (point: Point, context: CanvasRenderingContext2D) => {\n      context.lineTo(point[0], point[1]);\n      context.stroke();\n    },\n    []\n  );\n\n  const cursor = circleCursor(strokeWidth);\n\n  return { name: \"Eraser\", startStroke, continueStroke, cursor };\n}\n","export type Point = [number, number];\n\nexport const getTouchPoint = (event: React.TouchEvent): Point => {\n  if (!event.currentTarget) {\n    return [0, 0];\n  }\n  const rect = event.currentTarget.getBoundingClientRect();\n  const touch = event.targetTouches[0];\n  return [touch.clientX - rect.left, touch.clientY - rect.top];\n};\n\nexport const getMousePoint = (event: React.MouseEvent): Point => [\n  event.nativeEvent.offsetX,\n  event.nativeEvent.offsetY,\n];\n\nconst BUTTON = 0b01;\nexport const mouseButtonIsDown = (buttons: number): boolean =>\n  (BUTTON & buttons) === BUTTON;\n","import React, {\n  ForwardedRef,\n  forwardRef,\n  useCallback,\n  useImperativeHandle,\n  useState,\n  useEffect,\n} from \"react\";\n\nimport { History } from \"../history\";\n\nimport {\n  getMousePoint,\n  getTouchPoint,\n  mouseButtonIsDown,\n  Point,\n} from \"../utils/pointUtils\";\n\nexport interface ArtboardProps\n  extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  tool: ToolHandlers;\n  history?: History;\n  onStartStroke?: (point: Point) => void;\n  onContinueStroke?: (point: Point) => void;\n  onEndStroke?: () => void;\n}\n\nexport interface ArtboardRef {\n  download: (filename?: string, type?: string) => void;\n  getImageAsDataUri: (type?: string) => string | undefined;\n  clear: () => void;\n  context?: CanvasRenderingContext2D | null;\n}\n\nexport interface ToolHandlers {\n  name: string;\n  startStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\n  continueStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\n  endStroke?: (context: CanvasRenderingContext2D) => void;\n  cursor?: string;\n}\n\nexport const Artboard = forwardRef(function Artboard(\n  {\n    tool,\n    style,\n    history,\n    onStartStroke,\n    onContinueStroke,\n    onEndStroke,\n    ...props\n  }: ArtboardProps,\n  ref: ForwardedRef<ArtboardRef>\n) {\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>();\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\n  const [drawing, setDrawing] = useState(false);\n\n  const startStroke = useCallback(\n    (point: Point) => {\n      if (!context) {\n        return;\n      }\n      context.save();\n      setDrawing(true);\n      tool.startStroke?.(point, context);\n      onStartStroke?.(point);\n    },\n    [tool, context, onStartStroke]\n  );\n\n  const continueStroke = useCallback(\n    (newPoint: Point) => {\n      if (!context) {\n        return;\n      }\n      tool.continueStroke?.(newPoint, context);\n      onContinueStroke?.(newPoint);\n    },\n    [tool, context, onContinueStroke]\n  );\n\n  const endStroke = useCallback(() => {\n    setDrawing(false);\n    if (context) {\n      tool.endStroke?.(context);\n      onEndStroke?.();\n      context.restore();\n      if (canvas && history) {\n        history.pushState(canvas);\n      }\n    }\n  }, [tool, context, canvas, history, onEndStroke]);\n\n  const mouseMove = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      if (!drawing) {\n        return;\n      }\n      continueStroke(getMousePoint(event));\n    },\n    [continueStroke, drawing]\n  );\n\n  const touchMove = useCallback(\n    (event: React.TouchEvent) => {\n      if (!drawing) {\n        return;\n      }\n      continueStroke(getTouchPoint(event));\n    },\n    [continueStroke, drawing]\n  );\n\n  const mouseDown = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      if (drawing) {\n        return;\n      }\n      event.preventDefault();\n      startStroke(getMousePoint(event));\n    },\n    [drawing, startStroke]\n  );\n\n  const touchStart = useCallback(\n    (event: React.TouchEvent) => {\n      if (drawing) {\n        return;\n      }\n      startStroke(getTouchPoint(event));\n    },\n    [drawing, startStroke]\n  );\n\n  const clear = useCallback(() => {\n    if (!context || !canvas) {\n      return;\n    }\n    context.save();\n    context.fillStyle = \"#ffffff\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.restore();\n    if (canvas && history) {\n      history.pushState(canvas);\n    }\n  }, [context, canvas, history]);\n\n  const gotRef = useCallback(\n    (canvasRef: HTMLCanvasElement) => {\n      if (!canvasRef) {\n        return;\n      }\n      canvasRef.width = canvasRef.offsetWidth;\n      canvasRef.height = canvasRef.offsetHeight;\n      const ctx = canvasRef.getContext(\"2d\");\n      setCanvas(canvasRef);\n      setContext(ctx);\n      if (!ctx) {\n        return;\n      }\n      ctx.fillStyle = \"#ffffff\";\n      ctx.fillRect(0, 0, canvasRef.width, canvasRef.height);\n      ctx.fillStyle = \"transparent\";\n      if (history) {\n        history.setContext(ctx);\n        history.pushState(canvasRef);\n      }\n    },\n    [history]\n  );\n\n  const mouseEnter = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      // If mouse button is down but we're not drawing, start a new stroke\n      if (mouseButtonIsDown(event.buttons) && !drawing) {\n        mouseDown(event);\n      }\n    },\n    [drawing, mouseDown]\n  );\n\n  const mouseLeave = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      // Don't end the stroke when leaving the canvas - let the global mouse handlers manage this\n      // This allows continuous drawing when moving outside and back into the canvas\n    },\n    []\n  );\n\n  // Add global mouse event listeners for better drawing experience\n  useEffect(() => {\n    if (!drawing || !canvas) {\n      return;\n    }\n\n    const handleGlobalMouseMove = (event: MouseEvent) => {\n      if (!drawing) {\n        return;\n      }\n      \n      const rect = canvas.getBoundingClientRect();\n      const point: Point = [\n        event.clientX - rect.left,\n        event.clientY - rect.top\n      ];\n      \n      // Only process global mouse events when outside the canvas bounds\n      // This prevents double processing when drawing inside the canvas\n      const isOutsideCanvas = point[0] < 0 || point[0] > canvas.width || \n                              point[1] < 0 || point[1] > canvas.height;\n      \n      if (isOutsideCanvas && \n          point[0] >= -50 && point[0] <= canvas.width + 50 && \n          point[1] >= -50 && point[1] <= canvas.height + 50) {\n        continueStroke(point);\n      }\n    };\n\n    const handleGlobalMouseUp = () => {\n      if (drawing) {\n        endStroke();\n      }\n    };\n\n    document.addEventListener('mousemove', handleGlobalMouseMove);\n    document.addEventListener('mouseup', handleGlobalMouseUp);\n\n    return () => {\n      document.removeEventListener('mousemove', handleGlobalMouseMove);\n      document.removeEventListener('mouseup', handleGlobalMouseUp);\n    };\n  }, [drawing, canvas, continueStroke, endStroke]);\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      download: (filename = \"image.png\", type?: string) => {\n        if (!canvas) {\n          return;\n        }\n        const a = document.createElement(\"a\");\n        a.href = canvas.toDataURL(type);\n        a.download = filename;\n        a.click();\n      },\n      clear,\n      getImageAsDataUri: (type?: string) => canvas?.toDataURL(type),\n      context,\n    }),\n    [canvas, context, clear]\n  );\n\n  return (\n    <canvas\n      style={{ cursor: tool?.cursor, touchAction: \"none\", ...style }}\n      onTouchStart={touchStart}\n      onMouseDown={mouseDown}\n      onMouseEnter={mouseEnter}\n      onMouseMove={drawing ? mouseMove : undefined}\n      onTouchMove={drawing ? touchMove : undefined}\n      onMouseUp={endStroke}\n      onMouseOut={mouseLeave}\n      onTouchEnd={endStroke}\n      ref={gotRef}\n      {...props}\n    />\n  );\n});\n","import { useCallback, useMemo, useRef, useState } from \"react\";\n\nasync function applyImage(context: CanvasRenderingContext2D, blob: Blob) {\n  const img = new Image();\n  img.onload = () => {\n    context.canvas.width = img.width;\n    context.canvas.height = img.height;\n    context.drawImage(img, 0, 0);\n    URL.revokeObjectURL(img.src);\n  };\n  img.src = URL.createObjectURL(blob);\n}\n\nexport interface History {\n  setContext: (context: CanvasRenderingContext2D) => void;\n  pushState: (canvas: HTMLCanvasElement) => Promise<boolean>;\n}\nexport interface HistoryHook {\n  history: History;\n\n  undo: () => Promise<boolean>;\n  redo: () => Promise<boolean>;\n  clear: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n}\n\nexport function useHistory(size?: number): HistoryHook {\n  const stack = useRef<Array<Blob>>([]);\n  const crs = useRef(0);\n  const [context, setContext] = useState<CanvasRenderingContext2D>();\n  const [canUndo, setCanUndo] = useState(false);\n  const [canRedo, setCanRedo] = useState(false);\n\n  const pushState = useCallback(\n    async (canvas: HTMLCanvasElement) => {\n      const undoCursor = crs.current;\n      if (!context) {\n        console.error(\"Context not initialised\");\n        return false;\n      }\n      if (undoCursor !== 0) {\n        stack.current = stack.current.slice(0, -undoCursor);\n        crs.current = 0;\n      }\n      const blob = await new Promise<Blob | null>((resolve) =>\n        canvas.toBlob(resolve)\n      );\n      if (blob) {\n        stack.current.push(blob);\n      }\n      if (size && stack.current.length > size) {\n        stack.current = stack.current.slice(-size);\n      }\n      setCanUndo(stack.current.length > 1);\n      setCanRedo(false);\n      return true;\n    },\n    [crs, stack, context]\n  );\n  const undo = useCallback(async () => {\n    const undoCursor = crs.current;\n\n    if (!context) {\n      console.error(\"Context not initialised\");\n      return false;\n    }\n    if (undoCursor + 1 >= stack.current.length) {\n      console.log(\"nope\");\n      return false;\n    }\n\n    await applyImage(\n      context,\n      stack.current[stack.current.length - (undoCursor + 2)]\n    );\n    crs.current++;\n    setCanUndo(crs.current + 1 < stack.current.length);\n    setCanRedo(true);\n    return true;\n  }, [crs, stack, context]);\n\n  const redo = useCallback(async () => {\n    const undoCursor = crs.current;\n\n    if (!context) {\n      console.error(\"Context not initialised\");\n      return false;\n    }\n    if (undoCursor <= 0) {\n      return false;\n    }\n\n    await applyImage(context, stack.current[stack.current.length - undoCursor]);\n    crs.current--;\n    setCanUndo(crs.current + 1 < stack.current.length);\n    setCanRedo(crs.current > 0);\n    return true;\n  }, [stack, crs, context]);\n\n  const clear = useCallback(() => {\n    stack.current = [];\n  }, [stack]);\n\n  const history = useMemo<History>(\n    () => ({\n      setContext: (context: CanvasRenderingContext2D) => {\n        setContext(context);\n      },\n      pushState,\n    }),\n    [setContext, pushState]\n  );\n\n  return { history, undo, redo, clear, canUndo, canRedo };\n}\n"],"names":["varyColour","sourceColour","varyBrightness","amount","Math","round","random","alpha","tinycolor","darken","setAlpha","toPercentageRgbString","rotatePoint","distance","angle","origin","cos","sin","circleCursor","diameter","btoa","circleSVG","circleDataUri","useBrush","color","strokeWidth","useState","brush","setBrush","currentAngle","useRef","lastPoint","name","startStroke","useCallback","point","current","undefined","colour","bristleCount","gap","i","push","thickness","makeBrush","continueStroke","newPoint","context","newAngle","oldAngle","destination","bearing","atan2","PI","angleB","twoPi","diff","bristles","forEach","bristle","beginPath","controlPoint","moveTo","strokeStyle","lineWidth","lineCap","lineJoin","shadowColor","shadowBlur","quadraticCurveTo","lineTo","stroke","strokeBristle","drawStroke","cursor","useMarker","offset","globalAlpha","useAirbrush","globalCompositeOperation","console","log","endStroke","useShadingBrush","neighbourColor","distanceThreshold","neighbourStrokeWidth","spreadFactor","points","threshold","length","dx","dy","spareRandom","normalRandom","val","u","v","s","mul","sqrt","subdivideVertex","currentPoint","nextPoint","depth","variance","vdiv","midY","newMidpoint","newPoints","splodgeAtPoint","width","sides","radius","deformPolygon","centre","increment","result","makePolygon","getSplodge","closePath","fill","splodgeTrail","trail","count","min","useWatercolor","fillStyle","useEraser","getTouchPoint","event","currentTarget","rect","getBoundingClientRect","touch","targetTouches","clientX","left","clientY","top","getMousePoint","nativeEvent","offsetX","offsetY","mouseButtonIsDown","buttons","Artboard","forwardRef","ref","tool","style","history","onStartStroke","onContinueStroke","onEndStroke","props","setContext","canvas","setCanvas","drawing","setDrawing","save","restore","pushState","mouseMove","touchMove","mouseDown","preventDefault","touchStart","clear","fillRect","height","gotRef","canvasRef","offsetWidth","offsetHeight","ctx","getContext","mouseEnter","mouseLeave","useEffect","handleGlobalMouseMove","handleGlobalMouseUp","document","addEventListener","removeEventListener","useImperativeHandle","download","filename","type","a","createElement","href","toDataURL","click","getImageAsDataUri","_jsx","touchAction","onTouchStart","onMouseDown","onMouseEnter","onMouseMove","onTouchMove","onMouseUp","onMouseOut","onTouchEnd","applyImage","blob","img","Image","onload","drawImage","URL","revokeObjectURL","src","createObjectURL","useHistory","size","stack","crs","canUndo","setCanUndo","canRedo","setCanRedo","undoCursor","slice","Promise","resolve","toBlob","error","undo","redo","useMemo"],"mappings":"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"}